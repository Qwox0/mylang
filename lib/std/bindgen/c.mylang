std :: #import "std";
libc :: #import "libc";

clang :: #import "./libclang.mylang"; // TODO: commit libclang bindings (here or in another project?)

main :: -> {
    generate_c_bindings(
        "clang",
        "/home/qwox/lib/llvm/llvm-project/clang/include/clang-c/Index.h",
        .[
            "-I".ptr, "/home/qwox/lib/llvm/llvm-project/clang/include".ptr,
            "-I".ptr, "/usr/local/lib/clang/18/include".ptr, // stddef.h
        ][..],
        "./libclang.mylang",
        .{ convert_macros=false },
    );
}

cstr :: *u8;
Path :: []u8;

pub GenerateOpts :: struct {
    in_libc := false;

    trim_enum_prefix := true;
    trim_function_prefix := true; // TODO: replace with `?[]u8`
    /// defaults to `lib_name`
    function_prefix := "";
    trim_macro_prefix := true; // TODO: replace with `?[]u8`
    /// defaults to `function_prefix`
    macro_prefix := "";

    /// also for enum variants
    format_fields := true;
    indent_width := 4;

    copy_docs := true;

    convert_macros := true;
    skip_macros_starting_with_double_underscores := false;
}

pub generate_c_bindings :: (
    lib_name: []u8,
    header_file: Path,
    clang_args: []cstr,
    out_file: Path,
    mut opts := GenerateOpts.{},
) -> {
    if opts.function_prefix.len == 0 then opts.function_prefix = lib_name;
    if opts.macro_prefix.len == 0 then opts.macro_prefix = opts.function_prefix;

    idx := clang.createIndex(0, 0);
    defer clang.disposeIndex(idx);

    unit := clang.parseTranslationUnit(
        idx,
        header_file.ptr,
        clang_args.ptr, xx clang_args.len,
        nil, 0,
        (if opts.convert_macros then clang.enums.CXTranslationUnit_Flags.DetailedPreprocessingRecord
        else clang.enums.CXTranslationUnit_Flags.None).as(u32)
            //| clang.enums.CXTranslationUnit_Flags.SingleFileParse.as(u32)
        );
    defer clang.disposeTranslationUnit(unit);

    mut ok := true;

    if unit == nil {
        std.println("ERR: Clang couldn't parse translation unit\n");
        ok = false;
    }

    for diag_idx in 0..clang.getNumDiagnostics(unit) {
        diag := clang.getDiagnostic(unit, diag_idx);
        severity := clang.getDiagnosticSeverity(diag);
        ok &&= !(severity == .Error || severity == .Fatal);
        text := clang.formatDiagnostic(diag, clang.defaultDiagnosticDisplayOptions());
        defer clang.disposeString(text);

        libc.puts("Diagnostic: \"\"\"\n".ptr);
        libc.puts(clang.getCString(text));
        libc.puts("\"\"\"\n".ptr);
    }

    if !ok std.panic("clang failed");

    cursor := clang.getTranslationUnitCursor(unit);

    bindgen_file := libc.fopen(out_file.ptr, "w".ptr);
    defer libc.fclose(bindgen_file);

    mut tmp_alloc_buf: [1024 * 1024]u8;
    tmp_alloc := std.mem.FixedArenaAllocator.new(tmp_alloc_buf[..]mut);

    mut data := ClientData.{ unit, bindgen_file, lib_name, opts, tmp_alloc };
    defer data.free();

    data.&.emit("// Autogenerated bindings for `%s`\n\n", xx header_file.ptr);

    data.&.emit("#add_library_search_path \"%s\";\n", xx "/usr/local/lib".ptr); // TODO: correct path
    if not opts.in_libc data.&.emit("lib%s :: #library \"%s\";\n", xx lib_name.ptr, xx lib_name.ptr);

    data.&.emit("\n");

    data.&.emit("structs :: struct {};\n");
    data.&.emit("unions :: struct {};\n");
    data.&.emit("enums :: struct {};\n");

    data.&.emit("\n");

    clang.visitChildren(cursor, &visit_toplevel, xx &mut data);

    libc.printf("generated '%s'\n".ptr, out_file.ptr);
}

ClientData :: struct {
    unit: clang.CXTranslationUnit;
    bindgen_file: *libc.FILE;
    lib_name: []u8;
    item_name: []u8 = "";
    opts: GenerateOpts;

    tmp_alloc: std.mem.FixedArenaAllocator;

    // TODO: needs better hashing function
    used_names := std.set.StrHashSet.EMPTY;

    in_anon_type := false;

    ident_level := 0;

    free :: (mut self: ClientData) -> {
        self.used_names.&mut.reset_with_free();
        self.used_names.free();
    }
};

emit :: (data: *ClientData, fmt: []u8, a := 0, b := 0, c := 0, d := 0, e := 0) ->
    libc.fprintf(data.*.bindgen_file, fmt.ptr, a, b, c, d, e);

visit_toplevel :: (cursor: clang.CXCursor, parent: clang.CXCursor, d: *mut any) -> clang.enums.CXChildVisitResult {
    d := d.as(*mut ClientData);

    d.*.tmp_alloc.&mut.reset();

    d.*.item_name = d.tmp_alloc_cxstring(clang.getCursorSpelling(cursor));
    defer d.*.item_name = "";
    item_name := d.*.item_name.ptr;

    d.emit_docs(cursor);

    kind := clang.getCursorKind(cursor);

    if kind == .FunctionDecl {
        //is_fn_no_ret();
        fn_ty := clang.getCursorType(cursor);
        mut function_name := d.*.item_name;
        if d.*.used_names.&mut.insert(strclone(function_name.ptr)) != nil {
            d.emit("// DUPLICATE: ");
        } else if d.*.opts.trim_function_prefix {
            if trim_prefix(function_name.&mut, d.*.opts.function_prefix) {
                d.emit("#obj_symbol_name \"%s\"\n", xx d.*.item_name.ptr);
                function_name.&mut.as(*mut []mut u8).*[0] = to_lower_case(function_name[0]);
            }
        }
        d.emit("%s : ", xx function_name.ptr);
        d.emit_fn_proto(cursor);
        d.emit(" : #extern;\n");
    } else if kind == .StructDecl or kind == .UnionDecl {
        v := (if kind == .StructDecl "struct" else "union").ptr;

        struct_ty := clang.getCursorType(cursor);

        prev_in_anon_type := d.*.in_anon_type;
        d.*.in_anon_type = clang.cursor_isAnonymous(cursor) != 0;
        defer d.*.in_anon_type = prev_in_anon_type;

        if not d.*.in_anon_type then d.emit("%ss.%s :: ", xx v, xx item_name)
        else d.emit("// anonymous %s:\n", xx item_name);

        if d.*.in_anon_type {
            if d.*.ident_level > 0  d.*.ident_level += 1;
            d.emit_indent();
        }
        defer if d.*.in_anon_type if d.*.ident_level > 0  d.*.ident_level -= 1;

        is_incomplete := clang.type_getSizeOf(struct_ty) == xx clang.enums.CXTypeLayoutError.Incomplete;
        if is_incomplete {
            d.emit_opaque_ty();
            d.emit(";\n");
        } else {
            d.emit("%s { ", xx v, xx item_name, xx v);
            d.*.ident_level += 1;
            clang.type_visitFields(struct_ty, &(cursor, d) -> {
                d := d.as(*mut ClientData);
                mut field: *u8 = d.tmp_alloc_cxstring(clang.getCursorSpelling(cursor)).ptr;
                if libc.strlen(field) == 0 then field = "_".ptr; // TODO: better default

                if d.*.opts.format_fields { d.emit("\n"); d.emit_indent() }
                if d.emit_docs(cursor) then d.emit_indent();

                d.emit("%s: ", xx field);
                d.emit_type(clang.getCursorType(cursor));
                d.emit("; ");
                return .Continue;
            }, d);
            d.*.ident_level -= 1;
            if d.*.opts.format_fields {
                d.emit("\n");
                d.emit_indent();
            }
            d.emit("}\n");
        }
    } else if kind == .EnumDecl {
        enum_ty := clang.getCursorType(cursor);

        prev_in_anon_type := d.*.in_anon_type;
        d.*.in_anon_type = clang.cursor_isAnonymous(cursor) != 0;
        defer d.*.in_anon_type = prev_in_anon_type;

        if not d.*.in_anon_type then d.emit("enums.%s :: enum { ", xx item_name)
        else d.emit("// anonymous %s:\n", xx item_name);

        d.*.ident_level += 1;
        clang.visitChildren(cursor, &(cursor, p, d) -> {
            d := d.as(*mut ClientData);
            mut variant := d.tmp_alloc_cxstring(clang.getCursorSpelling(cursor));
            if d.*.opts.trim_enum_prefix {
                trim_partial_prefix(&mut variant, d.*.item_name);
            }
            mut variant: []u8 = variant;
            if variant.len == 0 then variant = "_"; // TODO: no duplicates

            std.assert(cursor.kind == .EnumConstantDecl);
            tag := clang.getEnumConstantDeclValue(cursor);

            if not d.*.in_anon_type {
                if d.*.opts.format_fields { d.emit("\n"); d.emit_indent() }
                if d.emit_docs(cursor) then d.emit_indent();

                d.emit("%s = %lld, ", xx variant.ptr, tag);
            } else {
                if d.*.used_names.&mut.insert(strclone(variant.ptr)) != nil d.emit("// DUPLICATE: ");
                if d.emit_docs(cursor) then d.emit_indent();
                d.emit("%s :: %lld;\n", xx variant.ptr, tag);
            }
            return .Continue;
        }, d);
        d.*.ident_level -= 1;

        if not d.*.in_anon_type {
            if d.*.opts.format_fields { d.emit("\n"); }
            d.emit("}\n");
        }
    } else if kind == .TypedefDecl {
        d.emit("%s :: ", xx item_name);
        d.emit_type(clang.getTypedefDeclUnderlyingType(cursor));
        d.emit(";\n");
    } else if kind == .VarDecl {
        d.emit("static %s: ", xx item_name);
        d.emit_type(clang.getCursorType(cursor));
        d.emit(" = #extern;\n");
    } else if kind == .MacroDefinition {
        d.emit_macro(cursor, d.*.item_name)
    } else if kind == .InclusionDirective {
        file := clang.getIncludedFile(cursor);
        filename := d.tmp_alloc_cxstring(clang.getFileName(file)).ptr;
        d.emit("\n// #include %s\n", xx filename);
    } else {
        kind_text := d.tmp_alloc_cxstring(clang.getCursorKindSpelling(kind)).ptr;

        d.emit( "// TODO(toplevel): %s: %s\n", xx item_name, xx kind_text);
    }

    return .Continue;
}

emit_fn_proto :: (d: *mut ClientData, cursor: clang.CXCursor) -> {
    fn_ty := clang.getCursorType(cursor);

    d.emit("(");

    param_count := clang.cursor_getNumArguments(cursor).as(u32);
    for idx in 0..param_count {
        param_cursor := clang.cursor_getArgument(cursor, idx);

        mut param_name := d.tmp_alloc_cxstring(clang.getCursorSpelling(param_cursor)).ptr;
        generate_param_name := libc.strlen(param_name) == 0;
        if generate_param_name {
            libc.asprintf(&mut param_name, "_%d".ptr, idx);
        }
        defer if generate_param_name libc.free(param_name);

        d.emit("%s: ", xx param_name);
        d.emit_type(clang.getArgType(fn_ty, idx));
        if idx != param_count - 1 {
            d.emit(", ");
        }
    }

    d.emit(") -> ");
    d.emit_type(clang.getResultType(fn_ty));
}

emit_type :: (d: *mut ClientData, ty: clang.CXType, is_pointee := false) -> {
    ty_text := d.tmp_alloc_cxstring(clang.getTypeSpelling(ty));

    if ty.kind == .Pointer {
        pointee := clang.getPointeeType(ty);
        if pointee.kind != .FunctionProto {
            is_const := clang.isConstQualifiedType(pointee) != 0;
            d.emit(if is_const "*" else "*mut ");
        }
        d.emit_type(clang.getUnqualifiedType(pointee), is_pointee=true);
    } else if ty.kind == .IncompleteArray {
        elem_ty := clang.getArrayElementType(ty);
        is_const := clang.isConstQualifiedType(elem_ty) != 0;
        d.emit(if is_const "*" else "*mut ");
        d.emit_type(clang.getUnqualifiedType(elem_ty), is_pointee=true);
    } else if ty.kind == .ConstantArray {
        len := clang.getArraySize(ty);
        d.emit("[%lld]", xx len);
        elem_ty := clang.getArrayElementType(ty);
        d.emit_type(elem_ty);
    } else if ty.kind == .Elaborated {
        cursor := clang.getTypeDeclaration(ty);

        is_incomplete := clang.type_getSizeOf(ty) == xx clang.enums.CXTypeLayoutError.Incomplete;
        if is_incomplete {
            d.emit_opaque_ty();
            return
        }

        name := d.tmp_alloc_cxstring(clang.getCursorSpelling(cursor)).ptr;
        is_anon := clang.cursor_isAnonymous(cursor) != 0;

        kind := clang.getCursorKindSpelling(cursor.kind);
        kind_text := if cursor.kind == .StructDecl "struct"
        else if cursor.kind == .UnionDecl "union"
        else if cursor.kind == .EnumDecl "enum"
        else if cursor.kind == .TypedefDecl {
            d.emit("%s", xx name);
            return;
        } else {
            kind := d.tmp_alloc_cxstring(clang.getCursorKindSpelling(cursor.kind)).ptr;
            libc.printf("unknown kind: %s\n".ptr, kind);
            std.panic("unknown kind")
        };

        if not is_anon { d.emit("%ss.%s", xx kind_text.ptr, xx name); }
        else { visit_toplevel(cursor, cursor, d); }
    } else if ty.kind == .FunctionProto {
        fn_ty := ty;
        d.emit("*(");

        param_count := clang.getNumArgTypes(fn_ty).as(u32);
        for idx in 0..param_count {
            param_cursor := clang.getArgType(fn_ty, idx);

            d.emit("_%d: ", xx idx);
            d.emit_type(clang.getArgType(fn_ty, idx));
            if idx != param_count - 1 {
                d.emit(", ");
            }
        }

        d.emit(") -> ");
        d.emit_type(clang.getResultType(fn_ty));
    } else if ty.kind == .Void and is_pointee {
        d.emit("any");
    } else {
        primitive := convert_primitive(ty.kind);
        if primitive != nil {
            d.emit("%s", xx primitive);
        } else {
            kind_text := d.tmp_alloc_cxstring(clang.getTypeKindSpelling(ty.kind)).ptr;

            std.panic(std.fmt.format("cannot convert type '%s' (%s))", xx ty_text.ptr, xx kind_text))
        }
    }
}

emit_macro :: (d: *mut ClientData, cursor: clang.CXCursor, mut macro_name: []u8) -> {
    if d.*.opts.skip_macros_starting_with_double_underscores && libc.strncmp(macro_name.ptr, "__".ptr, 2) == 0 return;

    if d.*.opts.trim_macro_prefix
        trim_prefix(macro_name.&mut, d.*.opts.macro_prefix);
    macro_name := macro_name.ptr;

    // TODO: get HashSet slot > cheaper insert later
    if d.*.used_names.&.contains_cstr(macro_name)
        d.emit("// DUPLICATE: ");


    tokens := d.tokenize_cursor(cursor);
    tokens := tokens[1..]; // The first token is always the macro ident

    if tokens.len == 0 {
        d.emit("// #define %s\n", xx macro_name);
        return
    } else if tokens.len > 1 {
        d.emit("// TODO(macro) %s ::", xx macro_name);
        for t in tokens {
            t_kind := clang.getTokenKind(t).get_token_kind_spelling();
            t_text := d.tmp_alloc_cxstring(clang.getTokenSpelling(d.*.unit, t)).ptr;

            d.emit(" '%s' (%s)", xx t_text, xx t_kind.ptr);
        }
        d.emit(";\n");
        return
    }

    t := tokens[0];
    t_kind := clang.getTokenKind(t);

    t_text := d.tmp_alloc_cxstring(clang.getTokenSpelling(d.*.unit, t));

    was_emitted := if t_kind == .Identifier {
        known_ident := d.*.used_names.&.contains(t_text);
        if not known_ident d.emit("// "); // exclude macros which expand to invalid text
        d.emit("%s :: %s;", xx macro_name, xx t_text.ptr);
        d.emit(" // %sIdentifier\n", xx (if known_ident "" else "Unknown ").ptr);
        known_ident
    } else if t_kind == .Literal {
        // TODO: allow floats
        mut exp_idx: u64 = 0;
        while exp_idx < t_text.len and t_text[exp_idx] != 'e' and t_text[exp_idx] != 'E'
            exp_idx += 1;
        skipped := exp_idx + 1 < t_text.len and (t_text[exp_idx + 1] == '+' or t_text[exp_idx + 1] == '-');
        if skipped d.emit("// skip float: ");

        mut suffix_start: u64 = t_text.len;
        while suffix_start > 0 {
            char := t_text[suffix_start - 1];
            if char != 'u' and char != 'U' and char != 'l' and char != 'L' break;
            suffix_start -= 1;
        }
        int_suffix := t_text[suffix_start..];

        d.emit("%s :", xx macro_name);
        if int_suffix.len != 0 {
            d.emit(" %s ", xx convert_int_suffix(int_suffix)); // TODO: suffix also works for float
        }
        d.emit(": %.*s; // kind: %d; suffix: '%s'\n", xx suffix_start, xx t_text.ptr, xx t_kind, xx t_text[suffix_start..].ptr);
        not skipped
    } else {
        d.emit("// TODO(macro) %s :: %s; (token_kind: %d)\n", xx macro_name, xx t_text.ptr, xx t_kind);
        false
    };

    if was_emitted d.*.used_names.&mut.insert(strclone(macro_name));
}

tokenize_cursor :: (d: *ClientData, cursor: clang.CXCursor) -> {
    range := clang.getCursorExtent(cursor);

    mut tokens: *mut clang.CXToken = nil;
    mut num_tokens: u32 = 0;
    clang.tokenize(d.*.unit, range, &mut tokens, &mut num_tokens);
    std.assert(tokens != nil);

    []clang.CXToken.{ ptr = tokens, len = xx num_tokens }
}

convert_primitive :: (kind: clang.enums.CXTypeKind) -> {
    if kind == .Void              "void".ptr
    else if kind == .Bool         "bool".ptr
    else if kind == .Char_U       "u8".ptr
    else if kind == .UChar        "u8".ptr
    //else if kind == .Char16       "".ptr
    //else if kind == .Char32       "".ptr
    else if kind == .UShort       "u16".ptr
    else if kind == .UInt         "u32".ptr
    else if kind == .ULong        "u64".ptr
    else if kind == .ULongLong    "u64".ptr
    else if kind == .UInt128      "u128".ptr
    else if kind == .Char_S       "u8".ptr // Is this correct?
    else if kind == .SChar        "i8".ptr
    //else if kind == .WChar        "".ptr
    else if kind == .Short        "i16".ptr
    else if kind == .Int          "i32".ptr
    else if kind == .Long         "i64".ptr
    else if kind == .LongLong     "i64".ptr
    else if kind == .Int128       "i128".ptr
    else if kind == .Float        "f32".ptr
    else if kind == .Double       "f64".ptr
    else if kind == .LongDouble   "f128".ptr // f80?
    //else if kind == .NullPtr      "".ptr
    //else if kind == .Overload     "".ptr
    //else if kind == .Dependent    "".ptr
    //else if kind == .ObjCId       "".ptr
    //else if kind == .ObjCClass    "".ptr
    //else if kind == .ObjCSel      "".ptr
    else if kind == .Float128     "f128".ptr
    //else if kind == .Half         "".ptr
    //else if kind == .Float16      "".ptr
    //else if kind == .ShortAccum   "".ptr
    //else if kind == .Accum        "".ptr
    //else if kind == .LongAccum    "".ptr
    //else if kind == .UShortAccum  "".ptr
    //else if kind == .UAccum       "".ptr
    //else if kind == .ULongAccum   "".ptr
    //else if kind == .BFloat16     "".ptr
    //else if kind == .Ibm128       "".ptr
    else if kind == .Complex      "any".ptr // TODO
    else nil
}

convert_int_suffix :: (suffix: []u8) -> {
    eq :: std.str.eq;
    convert_primitive(
        if eq(suffix, "u") or eq(suffix, "U") then .UInt
        else if eq(suffix, "l") or eq(suffix, "L") then .Long
        else if eq(suffix, "ul") or eq(suffix, "UL") then .ULong
        else if eq(suffix, "ll") or eq(suffix, "LL") then .LongLong
        else if eq(suffix, "ull") or eq(suffix, "uLL") then .ULongLong
        else std.panic(std.fmt.format("unexpected int suffix: \"%s\"", xx suffix.ptr))
    )
}

emit_opaque_ty :: (d: *ClientData) -> {
    d.emit("/* opaque */ any");
    //d.emit("struct { /* opaque */ }");
}

emit_docs :: (d: *mut ClientData, cursor: clang.CXCursor) -> {
    if !d.*.opts.copy_docs return false;

    s := clang.cursor_getRawCommentText(cursor);
    if clang.getCString(s) == nil return false;
    docs := d.tmp_alloc_cxstring(s).ptr;

    if docs == nil return false;

    d.emit("%s\n", xx docs);

    // TODO: reformat docs

    true
}

emit_indent :: (d: *ClientData) -> {
    for _ in 0..d.*.opts.indent_width * d.*.ident_level
        d.emit(" ")
}

debug_ty :: (d: *mut ClientData, ty: clang.CXType) -> {
    text := d.tmp_alloc_cxstring(clang.getTypeSpelling(ty)).ptr;
    kind := d.tmp_alloc_cxstring(clang.getTypeKindSpelling(ty.kind)).ptr;
    libc.printf("# type: %s (%s)\n".ptr, text, kind);
}

debug_cursor :: (d: *mut ClientData, cursor: clang.CXCursor) -> {
    name := d.tmp_alloc_cxstring(clang.getCursorSpelling(cursor)).ptr;
    kind := d.tmp_alloc_cxstring(clang.getCursorKindSpelling(cursor.kind)).ptr;
    cursor_range := clang.getCursorExtent(cursor);

    mut file: clang.CXFile;
    Pos :: struct { line: u32, column: u32, offset: u32 };
    mut start: Pos;
    clang.getExpansionLocation(clang.getRangeStart(cursor_range), &mut file, &mut start.line, &mut start.column, &mut start.offset);
    filename := d.tmp_alloc_cxstring(clang.getFileName(file)).ptr;

    libc.printf("# cursor: %s (%s)".ptr, name, kind);
    libc.printf(" ; %s:%d:%d(%d)\n".ptr, filename, start.line, start.column, start.offset);
}

tmp_alloc_cxstring :: (d: *mut ClientData, cxstring: clang.CXString) -> {
    defer clang.disposeString(cxstring);
    cstr := clang.getCString(cxstring);
    std.assert(cstr != nil, "expected non-null cstr");
    len := libc.strlen(cstr);

    str_buf := d.*.tmp_alloc.&mut.allocator().alloc(len + 1, 1);
    std.assert(str_buf != nil, "tmp allocation for cxstring failed");
    str := []mut u8.{ ptr=str_buf, len=len + 1};

    libc.memcpy(str_buf, cstr, len);
    str[len] = 0;

    str[..len]mut
}

strclone :: (str: *u8) -> std.fmt.format("%s", xx str);

trim_prefix :: (name: *mut []u8, prefix: []u8) -> bool {
    if name.*.len <= prefix.len return false;
    if not std.str.eq(name.*[..prefix.len], prefix) return false;
    mut new_start := prefix.len;
    if name.*[new_start] == '_' then new_start += 1;
    if name.*[new_start] > '0' and name.*[new_start] < '9' return false;
    name.* = name.*[new_start..];
    true
}

trim_partial_prefix :: (name: *mut []mut u8, prefix: []u8, make_lower := false) -> bool {
    mut idx: u64 = 0;
    max_idx := std.num.min(prefix.len, name.*.len);
    while idx < max_idx {
        if prefix[idx] != name.*[idx]
            break;
        idx += 1;
    }
    if idx > 0 and idx < name.*.len and name.*[idx] == '_'
        idx += 1;
    name.* = name.*[idx..]mut;
    if make_lower and name.*.len > 0 then name.*[0] = to_lower_case(name.*[0]);
    idx > 0
}

to_lower_case :: (char: u8) -> if 'A' <= char and char <= 'Z' then char + 'a' - 'A' else char;

get_token_kind_spelling :: (t_kind: clang.CXTokenKind) -> {
    if t_kind == .Punctuation "Punctuation"
    else if t_kind == .Keyword "Keyword"
    else if t_kind == .Identifier "Identifier"
    else if t_kind == .Literal "Literal"
    else if t_kind == .Comment "Comment"
    else "Invalid"
}
